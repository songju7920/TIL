## Hash란?

> 해시알고리즘은 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다

해시 알고리즘은 고정된 길이의 데이터로 매핑하여 조회 시간을 줄여주는 알고리즘이다.

해시 알고리즘을 사용해 [[Hash Table]]에 데이터를 추가하고 조회하고 싶다고 가정하면 다음과 같은 절차를 밟으면된다.

![[hash structure.png]]

1. 해시알고리즘을 통해 추가 할 단어를 특정 인덱스로 변환시킨다.
2. 해당 인덱스값과 일치하는 해시테이블의 위치에 데이터를 삽입한다
3. 꺼낼때는 다시한번 데이터의 값을 해시 알고리즘을 통해 특정 인덱스로 변환시킨다
4. 해당 인덱스값과 일치하는 해시테이블의 위치에 데이터를 꺼내온다

---
## Hash를 사용하는 이유

위에서 말했다시피 Hash를 사용하는 제일 궁극적인 이유는 빠른 조회와 빠른 저장을 위해서다. 이를 이용하여 시간복잡도를 거의 O(1)에 가깝게 만들 수 있으며, 이는 시간복잡도를 매우 줄일 수 있는 획기적인 알고리즘인 것이다.

---
## 충돌 (Collision)

해시에서의 충돌이란 해시테이블에서 이미 데이터가 있는 인덱스에 접근하여 데이터를 넣을려고 하는 행위를 말한다.
![[Hash Collision.png]]
위 그림을 보면 John Smith와 Sandra Dee가 해시 알고리즘을 거쳐 가공된 인덱스가 152로 같은 것을 볼 수있다. 이런 상황이 발생하면, 152인덱스에 이미 값이 있음에도 저장을 시도하는 상황이 발생하며, 이는 명백하게 해시 알고리즘에서 오류가 발생한 예라고 볼 수 있다.

### 해결 방법

이러한 해시 충돌이 발생할 경우, 다음과 같은 해결방법들을 고려해볼수 있다.

- __Separating Chaining (중복을 허용하는 방법)__
	충돌시 Linked list를 사용하여 해당 인덱스에 추가로 값을 넣어버리는 방법
	한 인덱스에 데이터가 6개 이하면 Linked list를, 8개이면 Tree를 사용하면서 혼용하며 사용하는 경우가 일반적이다.
	![[Separating Chaining.png]]
	위 사진처럼, 152에 중복이 발생시 Linked list를 사용하여 그 인덱스에 값을 넣어버린다.

- __Open addressing  (빈공간을 활용하는 방법)__
     충돌 시 가까이 있는 빈공간으로 접근, 채워넣는 방법.
     기본적으로 공간 활용을 제일 효율적으로 하는 방식이기 때문에 공간 복잡도가 제일 낮다.
     이 경우, 삭제시 더미 노드라는 것을 만들어서 다음 인덱스에 접근해야 하기때문에 삭제가 힘들다.
     ![[Linear Probing.png]]
     위에 보이는 구조는 Open addressing중 제일 대표적인 예인 Linear Probing이다.
    그림을 보면 Sandra Dee가 152로 충돌이 발생하여 다음 인덱스인 153에 저장되고, Ted Backer가 153에 접근 하려 했으나, 충돌이 발생하여 다음 인덱스인 154에 저장된것을 확인할 수 있다.

---
## 사용 범위

- 암호화
- 데이터 캐싱
- 코드의 효율적 작성
