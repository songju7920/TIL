## 시간 복잡도

> **시간 복잡도**란 어떤 알고리즘이 얼마만큼의 시간을 소요하는지를 나타낸다.
> 

> 알고리즘을 구성하는 명령어들이 몇번이나 실행됬는지 센 결과 + 각 명령어의 실행시간(execution time)의 곱
> 

| 시간 | 이름 | 1 | 2 | 4 | 8 | 16 | 32 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 상수형 | 1 | 1 | 1 | 1 | 1 | 1 |
| log 1 | 로그형 | 0 | 1 | 2 | 3 | 4 | 5 |
| n | 선형 | 1 | 2 | 4 | 8 | 16 | 32 |
| n log n | 선형 로그형 | 0 | 2 | 8 | 24 | 64 | 160 |
| n^2 | 평방형 | 1 | 4 | 16 | 64 | 256 | 1024 |
| n^3 | 입방형 | 1 | 8 | 64 | 512 | 4096 | 32768 |
| 2^n | 지수형 | 2 | 4 | 16 | 256 | 65536 | 42949672976 |
| 2! | 계승형 | 1 | 2 | 24 | 40326 | 2092278988800 | 26313*10^33 |
- 1(constant) : 입력자료의 수에 상관 없이 일정한 실행 시간을 가지는 알고리즘

```c
int algorithm (n) {
  return n+10;
}

int num = 10;
int result = algorithm(num);
printf("num + 10 = %d", num, result);
```

- log N : 만약 입력 자료의 수에 따라 실행 시간이 log N의 관계를 만족한다면 N이 증가함에 따라 실행시간이 조금씩 늘어난다. 경우의 수를 반으로 줄여나가면서 계산하는 방식으로, O(1) 다음으로 효율성이 제일 높다.
- N(Linear) : 입력 자료의 수에 따라 선형적으로 실행 시간이 걸리는 경우.

```c
void algorithm_1(repeat){
  for(int i = 0; i < repeat; i++)
    //do something for 1 sec
}
// 입력값이 5일시 5만큼의 시간소요 발생

void algorithm_2(repeat){
  for(int i = 0; i < 2*repeat; i++)
    //do something for 1 sec
}
// 입력값이 5일시 2*5만큼의 시간소요 발생
```

- N$^2$(quadratic) : 이중 루프(흔히 이중 반복문)내에서 입력 자료를 처리하는 경우에 나타난다.

```c
void algorithm(repeat){
  for(int i = 0; i < repeat; i++)
    for(int j = 0; j < repeat; j++)
      //do something for 1 sec
}
// 입력값이 5일시 5^2만큼의 시간소요 발생
```

- N$^3$(Cubic) : 입력 자료를 삼중 루프내에서 처리하는 경우에 나타난다.

```c
void algorithm_1(repeat){
  for(int i = 0; i < repeat; i++)
    for(int j = 0; j < repeat; j++)
      for(int k = 0; k < repeat; k++)
        //do something for 1 sec
}
// 입력값이 5일시 5^3만큼의 시간소요 발생
```

- 2**ⁿ :** 입력자료의 수가 늘어남에 따라 급격히 실행 시간이 늘어난다.

## 표기법

> 표기법은 빅 오, 세타, 오메가 표현법 총 3개가 존재한다
> 
- 빅-오 표기법 → O(N)
    
    최악의 경우를 표기한다 (제일 오래 걸릴 경우)
    
- 오메가 표현법 → Ω(N)
    
    최상의 경우를 표기한다 (제일 짧게 걸릴 경우)
    
- 세타 표기법 → θ(N)
    
    평균의 경우를 표기한다 (평균 정도 걸릴 경우)
    

> 보통 코딩에서는 최악의 상황을 항상 가정해야 하기 때문에 보통 빅-오 표기법을 사용한다.
>
